üöÄ Ping-Pong Performance Test Report
Generated: 2026-01-30

This report is generated by python script (using requests to send api with parameters m and n)


There are 3 strategies used in this exercise to generate random pixel. The objective is to increase the performance of generating pixels

1. SmallImageStrategy
   - Condition: m * n <= 784
   - new pixel is generated randomly by checking current pixels not used
   - 
  	(x, y) = random_empty_position(m, n, image)
   	color = random_unique_color(used_colors)

2. MediumImageStrategy
   - Condition: 785 <= m * n <= 10_000
   - The ideal is increasing the coordinate (x, y) by one for each ping or pong, generate color based on (x, y) to make sure that the colored pixels are unique
   - 
	idx = y * n + x
   	colors[i] = [
            (idx // (256 * 256)) % 256,  # Red component
            (idx // 256) % 256,           # Green component  
            idx % 256                     # Blue component
        ]

3. LargeImageStrategy
   - Condition: 10_001 <= m * n <= 20_000_000
   - Improved from MediumImageStrategy by sending batch of pixels for each ping or pong
   - 
	if total_pixels >= 10_000_000:
            batch_size = 2_000_000  # 2M pixels for massive grids (10 requests for 20M)
        elif total_pixels >= 4_000_000:
            batch_size = 1_000_000  # 1M pixels for huge grids (20 requests for 20M)
        elif total_pixels >= 1_000_000:
            batch_size = 500_000    # 500K pixels for large grids (40 requests for 20M)
        elif total_pixels >= 100_000:
            batch_size = 100_000    # 100K pixels for medium-large grids
        else:
            batch_size = 50_000   


üìä Performance Summary
----------------------------------------------------------------------------------------------------
Grid Size    Pixels       Strategy             Config (s)   Total (s)    Memory (MB)  Status      
----------------------------------------------------------------------------------------------------
5√ó5          25           Small                0.010        2.073        76.9         ‚úÖ Done      
10√ó10        100          Small                0.012        2.233        77.6         ‚úÖ Done      
28√ó28        784          Small                0.012        3.862        78.0         ‚úÖ Done      
56√ó56        3,136        Medium               0.013        7.171        78.1         ‚úÖ Done      
128√ó128      16,384       Large                0.013        2.078        78.2         ‚úÖ Done      
256√ó256      65,536       Large                0.029        2.127        78.2         ‚úÖ Done      
512√ó512      262,144      Large                0.012        2.385        78.2         ‚úÖ Done      
1024√ó1024    1,048,576    Large                0.014        3.438        78.3         ‚úÖ Done      
2048√ó2048    4,194,304    Large                0.011        7.016        78.3         ‚úÖ Done      
4072√ó4072    16,581,184   Large                0.012        21.735       24.2         ‚úÖ Done      
----------------------------------------------------------------------------------------------------

üìà Strategy Performance Analysis
------------------------------------------------------------
SmallImageStrategy:
  ‚Ä¢ Tests completed: 3/3
  ‚Ä¢ Average time: 2.723s
  ‚Ä¢ Average memory: 77.5 MB

MediumImageStrategy:
  ‚Ä¢ Tests completed: 1/1
  ‚Ä¢ Average time: 7.171s
  ‚Ä¢ Average memory: 78.1 MB

LargeImageStrategy:
  ‚Ä¢ Tests completed: 6/6
  ‚Ä¢ Average time: 6.463s
  ‚Ä¢ Average memory: 69.2 MB

üìä Overall Summary: 10/10 tests completed successfully
‚è±Ô∏è  Average completion time: 5.412 seconds



üîç Frontend Performance Analysis
 
* In frontend, the current implementation will crash when handling large grid sizes due to massive data transfer:
 
**Critical Issues Identified:**
 
1. **Memory Exhaustion**: 
   - 4072√ó4072 grid generates 16.5M pixels
   - Each pixel ~50 bytes in JSON format = ~825MB response
   - Browser memory limit exceeded ‚Üí Tab crashes
 
2. **Network Bandwidth**:
   - 825MB per API response
   - Slow loading times on standard connections
   - Mobile devices cannot handle such transfers
 
3. **Rendering Performance**:
   - Canvas rendering of 16.5M pixels causes browser freeze
   - DOM manipulation becomes unresponsive
   - User experience completely degraded
 
**Data Transfer Analysis by Grid Size:**
- 512√ó512 (262K pixels): ~13MB response ‚Üí Manageable but slow
- 1024√ó1024 (1M pixels): ~50MB response ‚Üí Significant delay
- 2048√ó2048 (4M pixels): ~200MB response ‚Üí Browser strain
- 4072√ó4072 (16.5M pixels): ~825MB response ‚Üí **CRASH**
 
üöÄ Performance Improvement Recommendations

## 1. **Compress Image Data**
    - use gzip, and base64 to compresse image from backend, then decompress from frontend

## 2. **WebSocket Implementation**
    - Since we know each pixel generated is unique, send it immediately to frontend, and frontend rendered right away on by one pixel.


üöÄ Technical Improvement Recommendations


## 1. **Integrate test for both frontend and backend**

## 2. **Integrate format, lint code both frontend and backend**









